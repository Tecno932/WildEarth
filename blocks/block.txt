esto es lo demas que me falto

atlasbuilder.cs
using UnityEngine;
using System.Collections.Generic;

public class AtlasBuilder : MonoBehaviour
{
    public static AtlasBuilder Instance;

    [Header("Atlas Manual")]
    public Texture2D manualAtlas;      // Asignalo desde el inspector (atlas.png)
    public int cellSize = 16;          // Tama√±o de cada bloque en p√≠xeles
    public int columns = 30;           // N√∫mero de columnas del atlas (30x30)

    [Header("Materials")]
    public Material defaultMaterial;
    public Material grassTintMaterial;

    private readonly Dictionary<string, Rect> uvRects = new();
    private readonly Dictionary<string, Material> materials = new();

    void Awake()
    {
        if (Instance == null) Instance = this;
        else { Destroy(gameObject); return; }

        BuildManualAtlas();
        BuildMaterials();
    }

    // ============================================================
    // üß© GENERACI√ìN DE UVS
    // ============================================================
    private void BuildManualAtlas()
    {
        uvRects.Clear();

        if (manualAtlas == null)
            manualAtlas = Resources.Load<Texture2D>("Atlas/atlas");

        if (manualAtlas == null)
        {
            Debug.LogError("‚ùå No se encontr√≥ atlas en Resources/Atlas/atlas.png");
            return;
        }

        // ‚úÖ Configuraci√≥n pixel-perfect
        manualAtlas.filterMode = FilterMode.Point;
        manualAtlas.wrapMode = TextureWrapMode.Clamp;

        float atlasWidth = manualAtlas.width;
        float atlasHeight = manualAtlas.height;

        // üü© UV exactos sin separaci√≥n
        float uvW = cellSize / atlasWidth;
        float uvH = cellSize / atlasHeight;

        // --- Registro de texturas ---
        uvRects["dirt"] = GetUVRect(0, 0, uvW, uvH);
        uvRects["dirt1"] = GetUVRect(1, 0, uvW, uvH);
        uvRects["dirt2"] = GetUVRect(2, 0, uvW, uvH);
        uvRects["dirt3"] = GetUVRect(3, 0, uvW, uvH);

        uvRects["grass_side"] = GetUVRect(4, 0, uvW, uvH);
        uvRects["grass_side_overlay"] = GetUVRect(6, 0, uvW, uvH);

        uvRects["grass_top"] = GetUVRect(0, 1, uvW, uvH);
        uvRects["grass_top1"] = GetUVRect(1, 1, uvW, uvH);
        uvRects["grass_top2"] = GetUVRect(2, 1, uvW, uvH);
        uvRects["grass_top3"] = GetUVRect(3, 1, uvW, uvH);
        uvRects["grass_top4"] = GetUVRect(4, 1, uvW, uvH);
        uvRects["grass_top5"] = GetUVRect(5, 1, uvW, uvH);
        uvRects["grass_top6"] = GetUVRect(6, 1, uvW, uvH);

        uvRects["gravel"] = GetUVRect(0, 2, uvW, uvH);
        uvRects["gravel1"] = GetUVRect(1, 2, uvW, uvH);
        uvRects["gravel2"] = GetUVRect(2, 2, uvW, uvH);
        uvRects["gravel3"] = GetUVRect(3, 2, uvW, uvH);

        uvRects["sand"] = GetUVRect(4, 2, uvW, uvH);
        uvRects["sand1"] = GetUVRect(5, 2, uvW, uvH);
        uvRects["sand2"] = GetUVRect(6, 2, uvW, uvH);

        uvRects["stone"] = GetUVRect(0, 3, uvW, uvH);
        uvRects["stone1"] = GetUVRect(1, 3, uvW, uvH);
        uvRects["limestone"] = GetUVRect(4, 3, uvW, uvH);
        uvRects["andesite"] = GetUVRect(5, 3, uvW, uvH);
        uvRects["granite"] = GetUVRect(6, 3, uvW, uvH);

        Debug.Log($"‚úÖ Atlas manual cargado correctamente ({atlasWidth}x{atlasHeight}) con {uvRects.Count} texturas.");
    }

    private Rect GetUVRect(int col, int row, float uvW, float uvH)
    {
        float u = col * uvW;
        float v = 1f - (row + 1) * uvH; // Invertido verticalmente (Unity)
        return new Rect(u, v, uvW, uvH);
    }

    // ============================================================
    // üé® MATERIALES
    // ============================================================
    private void BuildMaterials()
    {
        materials.Clear();

        if (manualAtlas == null)
        {
            Debug.LogError("‚ùå No se encontr√≥ el atlas para asignar materiales.");
            return;
        }

        // === Material base ===
        if (defaultMaterial != null)
        {
            Material mat = new(defaultMaterial);
            mat.name = "DefaultAtlasMat";
            mat.mainTexture = manualAtlas;
            mat.SetTexture("_BaseMap", manualAtlas);
            mat.mainTexture.filterMode = FilterMode.Point;
            mat.mainTexture.wrapMode = TextureWrapMode.Clamp;

            if (mat.HasProperty("_BaseColor"))
                mat.SetColor("_BaseColor", Color.white);

            materials["default"] = mat;
        }
        else
        {
            Debug.LogWarning("‚ö† No se asign√≥ Default Material en el AtlasBuilder.");
        }

        // === Material con tinte de pasto ===
        if (grassTintMaterial != null)
        {
            Material mat = new(grassTintMaterial);
            mat.name = "GrassTintAtlasMat";
            mat.mainTexture = manualAtlas;
            mat.SetTexture("_BaseMap", manualAtlas);
            mat.mainTexture.filterMode = FilterMode.Point;
            mat.mainTexture.wrapMode = TextureWrapMode.Clamp;
            mat.EnableKeyword("_BASEMAP");

            if (mat.HasProperty("_BaseColor"))
                mat.SetColor("_BaseColor", Color.white);
            if (mat.HasProperty("_TintStrength"))
                mat.SetFloat("_TintStrength", 1.0f);
            if (mat.HasProperty("_AlphaCutoff"))
                mat.SetFloat("_AlphaCutoff", 0.3f);

            materials["grasstint"] = mat;
        }
        else
        {
            Debug.LogWarning("‚ö† No se asign√≥ GrassTint Material en el AtlasBuilder.");
        }

        Debug.Log("‚úÖ Materiales del atlas listos: " + string.Join(", ", materials.Keys));
    }

    // ============================================================
    // üîé UTILIDADES
    // ============================================================
    public Rect GetUV(string name)
    {
        if (uvRects.TryGetValue(name, out Rect rect))
            return rect;

        Debug.LogWarning($"‚ö† UV no encontrado: {name}");
        return new Rect(0, 0, 1, 1);
    }

    public Material GetMaterialForBlock(string materialType)
    {
        if (string.IsNullOrEmpty(materialType))
            return materials["default"];

        string key = materialType.ToLower();

        if (materials.ContainsKey(key))
            return materials[key];

        return materials["default"];
    }

    // üîπ Requeridos por tus otros scripts
    public Texture2D GetAtlasTexture() => manualAtlas;
    public Material GetSharedMaterial() =>
        materials.ContainsKey("default") ? materials["default"] : null;
}

---

blockdata.cs
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

/// <summary>
/// Estructura de texturas del bloque.
/// </summary>
[System.Serializable]
public class BlockTextureInfo
{
    public string[] top;
    public string[] bottom;
    public string[] side;
    public string[] overlay;
    public string all;
}

/// <summary>
/// Estructura completa de datos de un bloque, extendida.
/// </summary>
[System.Serializable]
public class BlockInfo
{
    public string name;
    public string displayName;
    public string material = "Default";   // üîπ Material asignado (ej: "Default", "GrassTint")
    public string category = "Generic";   // üîπ Tipo de bloque: Soil, Rock, Wood, etc.
    public bool solid = true;
    public bool isTransparent = false;
    public bool isFlammable = false;
    public bool isSolid = true;
    public float hardness = 1.0f;         // üîπ Cu√°nto tarda en romperse
    public string tool = "Any";           // üîπ Herramienta ideal
    public string[] drops;                // üîπ Qu√© √≠tems suelta
    public float lightEmission = 0f;      // üîπ Luz emitida (0‚Äì1)
    public BlockTextureInfo textures;
}

/// <summary>
/// Base de datos de todos los bloques cargados desde BlockData.json
/// </summary>
public class BlockDatabase : MonoBehaviour
{
    public static BlockDatabase Instance;
    public Dictionary<string, BlockInfo> blocks;

    private void Awake()
    {
        if (Instance == null) Instance = this;
        else { Destroy(gameObject); return; }

        LoadBlockData();
    }

    private void LoadBlockData()
    {
        TextAsset json = Resources.Load<TextAsset>("BlockData");
        if (json == null)
        {
            Debug.LogError("‚ùå Falta BlockData.json en Resources/");
            return;
        }

        try
        {
            blocks = JsonConvert.DeserializeObject<Dictionary<string, BlockInfo>>(json.text);
            Debug.Log($"‚úÖ Cargados {blocks.Count} bloques desde JSON");
        }
        catch (System.Exception e)
        {
            Debug.LogError("‚ùå Error al leer JSON: " + e.Message);
        }
    }

    public BlockInfo GetBlock(string id)
    {
        if (blocks == null || !blocks.ContainsKey(id))
        {
            Debug.LogWarning($"‚ö† Bloque '{id}' no encontrado");
            return null;
        }
        return blocks[id];
    }

    /// <summary>
    /// Obtiene el material adecuado seg√∫n el tipo definido en el JSON.
    /// </summary>
    public Material GetMaterialForBlock(string blockId)
    {
        if (!blocks.TryGetValue(blockId, out var info))
            return AtlasBuilder.Instance.GetSharedMaterial();

        string matType = info.material?.ToLower() ?? "default";

        // ‚öôÔ∏è Delegamos la elecci√≥n del material al AtlasBuilder (por si en el futuro se ampl√≠a)
        return AtlasBuilder.Instance.GetMaterialForBlock(info.material);
    }
}




---

blockmaterial.cs
using UnityEngine;

[ExecuteAlways]
public class BlockMaterialSetup : MonoBehaviour
{
    [Tooltip("Arrastrar el material Blocks.mat aqu√≠ (el mismo que usa AtlasBuilder).")]
    public Material targetMaterial;

    void Start()
    {
        if (targetMaterial == null)
        {
            Debug.LogWarning("BlockMaterialSetup: no asignaste targetMaterial en el inspector.");
            return;
        }

        if (AtlasBuilder.Instance == null)
        {
            Debug.LogWarning("BlockMaterialSetup: AtlasBuilder.Instance no est√° listo a√∫n.");
            return;
        }

        Texture2D atlas = AtlasBuilder.Instance.GetAtlasTexture();
        if (atlas == null)
        {
            Debug.LogWarning("BlockMaterialSetup: atlas a√∫n no generado o es null.");
            return;
        }

        Material inst = Instantiate(targetMaterial);
        inst.name = targetMaterial.name + "_instance";

        if (inst.HasProperty("_MainTex"))
            inst.SetTexture("_MainTex", atlas);

        if (inst.HasProperty("_Color"))
            inst.SetColor("_Color", Color.white);

        if (inst.HasProperty("_Cull"))
            inst.SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Off);
        else
            inst.SetInt("_CullMode", 0);

        var rend = GetComponent<Renderer>();
        if (rend != null)
            rend.sharedMaterial = inst;

        // üîß NUEVO m√©todo no obsoleto
        Chunk[] chunks = Object.FindObjectsByType<Chunk>(FindObjectsSortMode.None);
        foreach (var c in chunks)
        {
            var mr = c.GetComponent<MeshRenderer>();
            if (mr != null) mr.sharedMaterial = inst;
        }

        Debug.Log($"BlockMaterialSetup: material instanciado y atlas asignado ({atlas.width}x{atlas.height}).");
    }
}

---

chunkworker.cs
using UnityEngine;
using System.Collections.Generic;
using System.Threading;

public static class ChunkWorker
{
    private static readonly Queue<Job> jobQueue = new();
    private static readonly List<Job> completedJobs = new();
    private static Thread workerThread;
    private static bool running = false;

    private class Job
    {
        public Vector3Int coord;
        public int size;
        public float heightMultiplier;
        public byte[,,] result;
    }

    public static void StartWorker()
    {
        if (running) return;
        running = true;
        workerThread = new Thread(ProcessJobs)
        {
            IsBackground = true,
            Name = "ChunkWorkerThread"
        };
        workerThread.Start();
        Debug.Log("[ChunkWorker] Hilo de generaci√≥n iniciado.");
    }

    public static void StopWorker()
    {
        running = false;
        workerThread?.Join();
        workerThread = null;
        Debug.Log("[ChunkWorker] Hilo detenido correctamente.");
    }

    public static void EnqueueJob(Vector3Int coord, int size, float noiseScale, float heightMultiplier)
    {
        lock (jobQueue)
        {
            jobQueue.Enqueue(new Job
            {
                coord = coord,
                size = size,
                heightMultiplier = heightMultiplier
            });
        }
    }

    public static bool TryGetCompletedJob(out byte[,,] data, out Vector2Int coord)
    {
        lock (completedJobs)
        {
            if (completedJobs.Count > 0)
            {
                var job = completedJobs[0];
                completedJobs.RemoveAt(0);
                data = job.result;
                coord = new Vector2Int(job.coord.x, job.coord.z);
                return true;
            }
        }

        data = null;
        coord = default;
        return false;
    }

    private static void ProcessJobs()
    {
        while (running)
        {
            Job job = null;
            lock (jobQueue)
            {
                if (jobQueue.Count > 0)
                    job = jobQueue.Dequeue();
            }

            if (job != null)
            {
                job.result = GenerateChunk(job.coord, job.size, job.heightMultiplier);
                lock (completedJobs)
                    completedJobs.Add(job);
            }

            Thread.Sleep(1);
        }
    }

    private static byte[,,] GenerateChunk(Vector3Int coord, int size, float heightMultiplier)
    {
        byte[,,] data = new byte[size, size, size];

        int baseX = coord.x * size;
        int baseZ = coord.z * size;

        for (int x = 0; x < size; x++)
        {
            for (int z = 0; z < size; z++)
            {
                float worldX = baseX + x;
                float worldZ = baseZ + z;

                // ‚úÖ Ruido global coherente
                float noiseValue = Noise.GetGlobal(worldX, worldZ);
                int terrainHeight = Mathf.FloorToInt(noiseValue * heightMultiplier);
                terrainHeight = Mathf.Clamp(terrainHeight, 1, size - 2);

                for (int y = 0; y < size; y++)
                {
                    if (y < terrainHeight - 3)
                        data[x, y, z] = 3;   // Stone
                    else if (y < terrainHeight)
                        data[x, y, z] = 1;   // Dirt
                    else if (y == terrainHeight)
                        data[x, y, z] = 2;   // Grass
                    else
                        data[x, y, z] = 0;   // Air
                }
            }
        }

        return data;
    }
}

---

hotbarinventory.cs
using UnityEngine;
using UnityEngine.InputSystem;

public class HotbarInventory : MonoBehaviour
{
    public byte[] slots = new byte[9];
    public int selectedSlot = 0;

    private PlayerBlockInteractor interactor;

    void Start()
    {
        interactor = GetComponent<PlayerBlockInteractor>();

        // bloques de prueba
        slots[0] = 1; // dirt
        slots[1] = 2; // grass
        slots[2] = 3; // stone
    }

    void Update()
    {
        var keyboard = Keyboard.current;
        if (keyboard == null) return;

        for (int i = 0; i < 9; i++)
        {
            // Key.Digit1, Key.Digit2, ..., Key.Digit9
            Key key = Key.Digit1 + i;

            if (keyboard[key].wasPressedThisFrame)
            {
                selectedSlot = i;
                if (interactor != null)
                    interactor.selectedBlock = slots[i];

                Debug.Log($"Seleccionado slot {i + 1} ‚Üí bloque {slots[i]}");
            }
        }
    }
}

---

chunkmanager.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ChunkManager : MonoBehaviour
{
    [Header("Chunk Settings")]
    public int chunkSize = 16;
    public int worldRadius = 3;
    public int worldHeight = 4; // n√∫mero de capas de chunks en vertical

    [Header("References")]
    public Transform player;
    public Material chunkMaterial;

    private Dictionary<Vector3Int, GameObject> activeChunks = new();
    private ChunkStorage storage;
    private bool generating = false;
    private Vector3Int lastPlayerChunk;

    private void Start()
    {
        storage = FindObjectOfType<ChunkStorage>();
        if (storage == null)
        {
            GameObject obj = new("ChunkStorage");
            storage = obj.AddComponent<ChunkStorage>();
        }

        ChunkWorker.StartWorker();
        StartCoroutine(UpdateChunksLoop());
    }

    private void OnDestroy()
    {
        ChunkWorker.StopWorker();
    }

    private IEnumerator UpdateChunksLoop()
    {
        while (true)
        {
            UpdateChunksAroundPlayer();
            yield return new WaitForSeconds(0.25f);
        }
    }

    private void UpdateChunksAroundPlayer()
    {
        if (player == null || generating) return;

        Vector3Int playerChunk = new(
            Mathf.FloorToInt(player.position.x / chunkSize),
            Mathf.FloorToInt(player.position.y / chunkSize),
            Mathf.FloorToInt(player.position.z / chunkSize)
        );

        if (playerChunk == lastPlayerChunk && activeChunks.Count > 0)
            return;

        lastPlayerChunk = playerChunk;
        StartCoroutine(GenerateChunksAroundPlayer(playerChunk));
    }

    private IEnumerator GenerateChunksAroundPlayer(Vector3Int center)
    {
        generating = true;

        List<Vector3Int> needed = new();
        for (int x = -worldRadius; x <= worldRadius; x++)
        {
            for (int z = -worldRadius; z <= worldRadius; z++)
            {
                for (int y = 0; y < worldHeight; y++) // genera niveles verticales
                {
                    needed.Add(new Vector3Int(center.x + x, y, center.z + z));
                }
            }
        }

        // eliminar chunks fuera del rango
        List<Vector3Int> toRemove = new();
        foreach (var kv in activeChunks)
            if (!needed.Contains(kv.Key))
                toRemove.Add(kv.Key);

        foreach (var coord in toRemove)
        {
            ChunkPool.Instance.ReturnChunk(activeChunks[coord]);
            activeChunks.Remove(coord);
        }

        // generar nuevos chunks
        foreach (var coord in needed)
        {
            if (activeChunks.ContainsKey(coord)) continue;

            byte[,,] data = null;
            if (storage.HasData(new Vector2Int(coord.x, coord.z)))
            {
                data = storage.GetChunkData(new Vector2Int(coord.x, coord.z));
            }
            else
            {
                ChunkWorker.EnqueueJob(coord, chunkSize, 0.08f, 16f);
                yield return new WaitUntil(() => ChunkWorker.TryGetCompletedJob(out data, out var c) &&
                    c.x == coord.x && c.y == coord.z);
                if (data != null)
                    storage.SaveChunk(new Vector2Int(coord.x, coord.z), data);
            }

            if (data != null)
                CreateChunk(coord, data);

            yield return null;
        }

        generating = false;
    }

    private void CreateChunk(Vector3Int coord, byte[,,] data)
    {
        Vector3 pos = new(coord.x * chunkSize, coord.y * chunkSize, coord.z * chunkSize);
        GameObject chunkObj = ChunkPool.Instance.GetChunk(pos, transform);

        Chunk chunk = chunkObj.GetComponent<Chunk>();
        chunk.material = chunkMaterial ?? AtlasBuilder.Instance.GetSharedMaterial();
        chunk.size = chunkSize;
        chunk.SetData(data, coord, FindObjectOfType<WorldGenerator>());
        activeChunks[coord] = chunkObj;

        Debug.Log($"üü© Chunk generado en {coord}");
    }
}

---

chunkpool.cs
using System.Collections.Generic;
using UnityEngine;

public class ChunkPool : MonoBehaviour
{
    public static ChunkPool Instance { get; private set; }

    private readonly Queue<GameObject> pool = new Queue<GameObject>();

    private void Awake()
    {
        if (Instance != null && Instance != this)
            Destroy(gameObject);
        else
            Instance = this;
    }

    public GameObject GetChunk(Vector3 position, Transform parent = null)
    {
        GameObject obj;
        if (pool.Count > 0)
        {
            obj = pool.Dequeue();
            obj.SetActive(true);
        }
        else
        {
            obj = new GameObject("Chunk");
            obj.AddComponent<Chunk>();
        }

        obj.transform.parent = parent;
        obj.transform.position = position;
        return obj;
    }

    public void ReturnChunk(GameObject chunk)
    {
        chunk.SetActive(false);
        pool.Enqueue(chunk);
    }
}

---

worldgenerator.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class WorldGenerator : MonoBehaviour
{
    [Header("World Settings")]
    public int chunkSize = 16;
    public int worldRadius = 512;
    public int viewRadius = 8;
    public float updateInterval = 0.25f;

    [Header("Noise Settings")]
    public float noiseScale = 0.08f;
    public float heightMultiplier = 16f;

    [Header("Seed Settings")]
    public int customSeed = 0;

    [Header("Precompute (cache)")]
    public int precomputeRadius = 0;
    public int precomputeBatchSize = 256;

    [Header("References")]
    public Transform player;
    public Material defaultMaterial;
    public Material tintedMaterial;

    private Dictionary<Vector2Int, GameObject> activeChunks = new();
    private ChunkStorage storage;
    private Vector2Int lastPlayerChunk = new(int.MinValue, int.MinValue);
    private bool generating = false;

    void Start()
    {
        if (customSeed != 0)
        {
            WorldSettings.InitializeSeed(customSeed);
            Debug.Log($"üåç Usando semilla personalizada: {customSeed}");
        }
        else
        {
            WorldSettings.InitializeSeed();
            Debug.Log($"üåç Semilla aleatoria generada: {WorldSettings.Seed}");
        }

        storage = Object.FindFirstObjectByType<ChunkStorage>();
        if (storage == null)
        {
            GameObject obj = new("ChunkStorage");
            storage = obj.AddComponent<ChunkStorage>();
            Debug.Log("[WorldGenerator] ChunkStorage creado en runtime.");
        }

        ChunkWorker.StartWorker();
        Debug.Log("[WorldGenerator] ChunkWorker iniciado.");

        StartCoroutine(WaitForAtlasThenGenerate());
    }

    void OnDestroy() => ChunkWorker.StopWorker();

    private IEnumerator WaitForAtlasThenGenerate()
    {
        yield return new WaitUntil(() =>
            AtlasBuilder.Instance != null &&
            AtlasBuilder.Instance.GetAtlasTexture() != null);

        if (precomputeRadius > 0)
            StartCoroutine(PrecomputeWorldData(precomputeRadius));

        StartCoroutine(UpdateWorldLoop());
    }

    private IEnumerator UpdateWorldLoop()
    {
        while (true)
        {
            UpdateChunksAroundPlayer();
            yield return new WaitForSeconds(updateInterval);
        }
    }

    private void UpdateChunksAroundPlayer()
    {
        if (player == null || generating) return;

        Vector2Int playerChunk = new(
            Mathf.FloorToInt(player.position.x / chunkSize),
            Mathf.FloorToInt(player.position.z / chunkSize)
        );

        if (playerChunk != lastPlayerChunk)
        {
            lastPlayerChunk = playerChunk;
            StartCoroutine(GenerateChunksAroundPlayer(playerChunk));
        }
    }

    private IEnumerator GenerateChunksAroundPlayer(Vector2Int center)
    {
        generating = true;

        List<Vector2Int> needed = new();
        for (int x = -viewRadius; x <= viewRadius; x++)
        for (int z = -viewRadius; z <= viewRadius; z++)
        {
            Vector2Int coord = new(center.x + x, center.y + z);
            if (Mathf.Abs(coord.x) > worldRadius || Mathf.Abs(coord.y) > worldRadius) continue;
            needed.Add(coord);
        }

        needed.Sort((a, b) => Vector2.Distance(a, center).CompareTo(Vector2.Distance(b, center)));

        List<Vector2Int> toRemove = new();
        foreach (var kv in activeChunks)
            if (!needed.Contains(kv.Key))
                toRemove.Add(kv.Key);

        foreach (var coord in toRemove)
        {
            ChunkPool.Instance.ReturnChunk(activeChunks[coord]);
            activeChunks.Remove(coord);
        }

        foreach (var coord in needed)
        {
            if (activeChunks.ContainsKey(coord)) continue;

            byte[,,] data = storage?.GetChunkData(coord);
            if (data == null)
            {
                Vector3Int chunkCoord = new(coord.x, 0, coord.y);
                ChunkWorker.EnqueueJob(chunkCoord, chunkSize, noiseScale, heightMultiplier);
                float timeout = Time.realtimeSinceStartup + 10f;

                while (Time.realtimeSinceStartup < timeout)
                {
                    if (ChunkWorker.TryGetCompletedJob(out data, out var completedCoord))
                    {
                        if (completedCoord.x == chunkCoord.x && completedCoord.y == chunkCoord.z)
                            break;
                    }
                    yield return null;
                }

                if (data != null && storage != null)
                    storage.SaveChunk(coord, data);
            }

            if (data != null)
                CreateChunk(coord, data, chunkSize);

            yield return null;
        }

        generating = false;
    }

    private void CreateChunk(Vector2Int coord, byte[,,] data, int size)
    {
        Vector3 pos = new(coord.x * size, 0, coord.y * size);
        GameObject chunkObj = ChunkPool.Instance.GetChunk(pos, transform);

        Chunk chunk = chunkObj.GetComponent<Chunk>();
        if (chunk == null)
        {
            Debug.LogError("[WorldGenerator] El objeto obtenido no tiene componente Chunk.");
            return;
        }

        chunk.Initialize(data, new Vector3Int(coord.x, 0, coord.y), this);
        activeChunks[coord] = chunkObj;
    }

    public Vector3Int GetBlockCoords(Vector3 worldPos)
    {
        return new Vector3Int(
            Mathf.FloorToInt(worldPos.x),
            Mathf.FloorToInt(worldPos.y),
            Mathf.FloorToInt(worldPos.z)
        );
    }

    public void SetBlock(Vector3Int pos, byte id)
    {
        Vector3Int chunkCoord = new(
            Mathf.FloorToInt((float)pos.x / chunkSize),
            Mathf.FloorToInt((float)pos.y / chunkSize),
            Mathf.FloorToInt((float)pos.z / chunkSize)
        );

        Chunk chunk = GetChunk(chunkCoord);
        if (chunk == null) return;

        int lx = Mathf.Clamp((pos.x % chunkSize + chunkSize) % chunkSize, 0, chunkSize - 1);
        int ly = Mathf.Clamp(pos.y, 0, chunkSize - 1);
        int lz = Mathf.Clamp((pos.z % chunkSize + chunkSize) % chunkSize, 0, chunkSize - 1);

        chunk.SetBlock(new Vector3Int(lx, ly, lz), id);
    }

    private IEnumerator PrecomputeWorldData(int radius)
    {
        yield break;
    }

    public byte[,,] GetChunkBlocks(Vector3Int chunkCoord)
    {
        Vector2Int key = new(chunkCoord.x, chunkCoord.z);
        return storage?.GetChunkData(key);
    }

    public Chunk GetChunk(Vector3Int chunkCoord)
    {
        Vector2Int key = new(chunkCoord.x, chunkCoord.z);
        return activeChunks.TryGetValue(key, out GameObject obj) ? obj.GetComponent<Chunk>() : null;
    }
}

---

worldseting.cs
using UnityEngine;

public static class WorldSettings
{
    public static int Seed { get; private set; }
    public static Vector2 Offset { get; private set; }
    private static bool initialized = false;

    /// <summary>
    /// Inicializa la seed global del mundo (solo una vez).
    /// Si pasas null -> seed aleatoria.
    /// </summary>
    public static void InitializeSeed(int? seed = null)
    {
        if (initialized) return;
        initialized = true;

        Seed = seed ?? Random.Range(int.MinValue, int.MaxValue);

        // Offset global derivado de la seed para evitar coordenadas negativas problem√°ticas
        System.Random rng = new System.Random(Seed);
        Offset = new Vector2(rng.Next(-100000, 100000), rng.Next(-100000, 100000));

        Debug.Log($"üå± Semilla mundial generada: {Seed} | Offset: {Offset}");
    }
}

---

eso es gran parte de mi codigo, quiero que arregles lo de no poder romper ni poner bloques, lee todo a detalle 